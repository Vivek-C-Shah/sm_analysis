import os
import gradio as gr
import pandas as pd
import matplotlib.pyplot as plt
from typing import List
import time

from data_pipeline import DataPipeline

pipeline = DataPipeline()

# ---------------- Helper Functions ---------------- #
def load_data(data_source, database_collection, csv_file):
    """
    Loads data from either database or CSV.
    Returns a full pandas DataFrame.
    """
    print(f"Loading data from source: {data_source}")  # Debug print
    if data_source == "Load from Database":
        if not database_collection:
            raise ValueError("Please select a database collection.")
        try:
            print(f"Fetching data from collection: {database_collection}")  # Debug print
            collection_data = pipeline.get_collection_data(database_collection)
            df = pd.DataFrame(list(collection_data))
        except Exception as e:
            raise Exception(f"Failed to load data from database: {e}")

    elif data_source == "Upload CSV File":
        if not csv_file:
            raise ValueError("Please upload a CSV file.")
        try:
            print(f"Loading CSV file: {csv_file.name}")  # Debug print
            df = pipeline.read_csv(csv_file.name)
        except Exception as e:
            raise Exception(f"Failed to load data from CSV: {e}")

    else:
        raise ValueError("Invalid Data Source Selected")

    print(f"Data loaded successfully with shape: {df.shape}")  # Debug print
    if df is not None and not df.empty:
        return df, df.head()
    else:
        return pd.DataFrame(), pd.DataFrame()


def preview_dataframe(df: pd.DataFrame):
    """
    Returns a small sample (head) of the DataFrame for display.
    Used as the output for a Gradio Dataframe with type='pandas'.
    """
    print(f"Previewing dataframe with shape: {df.shape}")  # Debug print
    if df is not None and not df.empty:
        return df.head()
    else:
        return pd.DataFrame()


def get_post_types(df: pd.DataFrame):
    """
    Extracts unique post types from the DataFrame.
    Returns a list to update a Dropdown in Gradio.
    """
    print(f"Extracting post types from dataframe")  # Debug print
    if df is not None and not df.empty:
        return ["All Post Types"] + df["post_type"].unique().tolist()
    return ["All Post Types"]


def calculate_engagement_metrics(data, selected_post_type, metric_types):
    """
    Calculates engagement metrics based on selection.
    Returns a pandas DataFrame of metrics.
    """
    print(f"Calculating engagement metrics for post type: {selected_post_type} and metrics: {metric_types}")  # Debug print
    if data is None or data.empty:
        return pd.DataFrame()

    if selected_post_type == "All Post Types":
        metrics_df = pipeline.get_engagement_metrics_by_post_type(data)
    else:
        filtered_data = data[data["post_type"] == selected_post_type]
        metrics_df = pipeline.get_engagement_metrics(filtered_data)

    if metric_types:
        metrics_df = metrics_df[["post_type"] + metric_types]
    
    print(f"Calculated metrics with shape: {metrics_df.shape}")  # Debug print
    return metrics_df


def generate_insights(metrics_df: pd.DataFrame, prompt_len: int = 300) -> str:
    """
    Generates insights using the DataPipeline and an LLM.
    """
    print(f"Generating insights for dataframe with shape: {metrics_df.shape}")  # Debug print
    if metrics_df.empty:
        return "No data to generate insights from."

    system_prompt = pipeline.generate_system_prompt()
    payload = pipeline.generate_payload(metrics_df, system_prompt)
    insights = pipeline.get_engagement_insights(payload)

    if insights:
        return insights
    else:
        return "No insights generated by the Langflow API."


def plot_comparison(data: pd.DataFrame, compare_by: str, metric_types: List[str]) -> plt.Figure:
    """
    Generates comparative bar plots of the specified metrics by post type or date.
    """
    print(f"Generating comparison plot by {compare_by} with metrics: {metric_types}")  # Debug print
    if data is None or data.empty:
        return None

    if compare_by == "post_type":
        metrics_df = pipeline.get_engagement_metrics_by_post_type(data)
    elif compare_by == "date":
        metrics_df = pipeline.get_engagement_metrics_by_date(data)
    else:
        return None

    if metrics_df.empty or not metric_types:
        return None

    # Limit to selected columns
    metrics_df = metrics_df[[compare_by] + metric_types]
    metrics_df = metrics_df.set_index(compare_by)

    fig, ax = plt.subplots(figsize=(10, 6))
    metrics_df.plot(kind="bar", ax=ax)
    ax.set_title(f"Metric Comparison by {compare_by}")
    ax.set_ylabel("Values")
    ax.tick_params(axis="x", rotation=45)
    plt.tight_layout()
    return fig


def update_analysis(df: pd.DataFrame, selected_post_type, metric_types, prompt_len, compare_by):
    """
    Uses the stored DataFrame to generate metrics, insights, and comparison plots.
    """
    print("Updating analysis")  # Debug print
    if df is None or df.empty:
        return pd.DataFrame(), "", None

    engagement_metrics = calculate_engagement_metrics(df, selected_post_type, metric_types)
    insights = generate_insights(engagement_metrics, prompt_len)
    comparison_plot = plot_comparison(df, compare_by, metric_types)
    # time.sleep(10)
    print("Analysis updated successfully")  # Debug print
    print(f"Engagement Metrics: {engagement_metrics.shape}, Insights: {(insights)}")  # Debug print
    return engagement_metrics, insights, comparison_plot


# -------------- BUILD THE GRADIO INTERFACE -------------- #
with gr.Blocks() as demo:
    gr.Markdown("# Social Media Engagement Analysis Tool - By Edgy Coders")

    # A State object to hold the DataFrame after loading
    df_state = gr.State()

    # ---------------- TAB: DATA LOADING ---------------- #
    with gr.Tab("Data Loading"):
        with gr.Row():
            data_source = gr.Radio(
                choices=["Load from Database", "Upload CSV File"],
                label="Select Data Source",
                value="Load from Database"
            )
        with gr.Row():
            database_collection = gr.Dropdown(
                choices=pipeline.list_collections(),
                label="Database Collection",
                visible=True
            )
            csv_file = gr.File(
                label="Upload CSV File",
                file_types=[".csv"],
                visible=False
            )

        def toggle_inputs(src):
            # Show/hide DB dropdown or CSV upload based on data_source selection
            print(f"Toggling inputs based on data source: {src}")  # Debug print
            return (
                gr.update(visible=(src == "Load from Database")),
                gr.update(visible=(src == "Upload CSV File"))
            )

        data_source.change(
            toggle_inputs,
            inputs=[data_source],
            outputs=[database_collection, csv_file]
        )

        load_button = gr.Button("Load Data")

        # We'll show a small preview using type='pandas' 
        data_preview = gr.Dataframe(
            label="Data Preview",
            type="pandas"   # Accepts a Pandas DataFrame
        )

        load_button.click(
            fn=load_data,
            inputs=[data_source, database_collection, csv_file],
            outputs=[df_state, data_preview],
            api_name="load_data"
        )

    # ---------------- TAB: ANALYSIS ---------------- #
    with gr.Tab("Analysis"):
        with gr.Row():
            post_type_dropdown = gr.Dropdown(
                # Start with "All Post Types" to avoid warnings
                choices=["All Post Types"],   
                label="Select Post Type",
                value="All Post Types",
                allow_custom_value=True  # In case "All Post Types" isn't in the pipeline yet
            )
            metric_types_group = gr.CheckboxGroup(
                choices=[
                    "avg_likes", "avg_shares", "avg_comments", 
                    "engagement_rate", "like_to_comment_ratio", "share_to_like_ratio"
                ],
                label="Select Metrics",
                value=["engagement_rate"]
            )

        with gr.Row():
            prompt_length_slider = gr.Slider(
                minimum=100,
                maximum=500,
                value=300,
                label="Prompt Length",
                step=50
            )

        with gr.Row():
            compare_by_radio = gr.Radio(
                choices=["post_type", "date"],
                label="Compare By:",
                value="post_type"
            )

        with gr.Row():
            analysis_button = gr.Button("Analyze")

        # Analysis outputs
        engagement_metrics_output = gr.Dataframe(
            label="Engagement Metrics",
            type="pandas"
        )
        comparison_plot_output = gr.Plot(
            label="Metrics Comparison"
        )
        engagement_insights_output = gr.Markdown(
            label="Engagement Insights"
        )

        # Populate post_type_dropdown after data load
        def _after_load(df):
            """
            Return the updated list of post types for the dropdown 
            (includes "All Post Types").
            """
            print(f"Updating post type dropdown after data load")  # Debug print
            updated_choices = get_post_types(df)
            return gr.update(choices=updated_choices, value="All Post Types")

        load_button.click(
            fn=_after_load,
            inputs=[df_state],
            outputs=[post_type_dropdown]
        )

        # Handle analysis
        analysis_button.click(
            fn=update_analysis,
            inputs=[
                df_state, 
                post_type_dropdown, 
                metric_types_group, 
                prompt_length_slider, 
                compare_by_radio
            ],
            outputs=[
                engagement_metrics_output, 
                engagement_insights_output, 
                comparison_plot_output
            ],
            api_name="update_analysis"
        )

    # ---------------- TAB: SETTINGS ---------------- #
    with gr.Tab("Settings"):
        gr.Markdown("### Customize Application Settings")

demo.launch()